name: CD

on:
  workflow_run:
    workflows: ["CI"]
    branches: ["main"]
    types: [completed]
    paths-ignore:
      - 'infra/backend.hcl'
      - '**/*.tfstate*'
      - '**/*.log'
      - '**/.terraform/**'
  workflow_dispatch: {}

concurrency:
  group: cd-${{ github.ref }}
  cancel-in-progress: true

env:
  AWS_REGION: eu-north-1
  PROJECT_NAME: cafe
  TF_IN_AUTOMATION: 'true'
  TF_INPUT: 'false'

jobs:
  infra_bootstrap:
    name: Terraform bootstrap (create/update infra prerequisites)
    if: ${{ github.event_name == 'workflow_dispatch' || github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest
    timeout-minutes: 45
    outputs:
      repo_uri: ${{ steps.tf_outputs.outputs.repo_uri }}
      asg_name: ${{ steps.tf_outputs.outputs.asg_name }}
      alb_dns: ${{ steps.tf_outputs.outputs.alb_dns }}
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials (GitHub Secrets)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Who am I (AWS STS)
        run: aws sts get-caller-identity

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.6

      - name: Ensure backend S3 bucket exists
        run: |
          set -e
          if aws s3api head-bucket --bucket "${{ steps.acct.outputs.BUCKET }}" 2>/dev/null; then
            echo "Bucket exists: ${{ steps.acct.outputs.BUCKET }}"
          else
            if [ "${{ env.AWS_REGION }}" = "us-east-1" ]; then
              aws s3api create-bucket \
                --bucket "${{ steps.acct.outputs.BUCKET }}" \
                --region ${{ env.AWS_REGION }}
            else
              aws s3api create-bucket \
                --bucket "${{ steps.acct.outputs.BUCKET }}" \
                --region ${{ env.AWS_REGION }} \
                --create-bucket-configuration LocationConstraint=${{ env.AWS_REGION }}
            fi
          fi

      - name: Ensure DynamoDB lock table exists
        run: |
          set -e
          if aws dynamodb describe-table --table-name "${{ steps.acct.outputs.LOCK_TABLE }}" >/dev/null 2>&1; then
            echo "Lock table exists: ${{ steps.acct.outputs.LOCK_TABLE }}"
          else
            aws dynamodb create-table \
              --table-name "${{ steps.acct.outputs.LOCK_TABLE }}" \
              --attribute-definitions AttributeName=LockID,AttributeType=S \
              --key-schema AttributeName=LockID,KeyType=HASH \
              --billing-mode PAY_PER_REQUEST \
              --region ${{ env.AWS_REGION }}
            aws dynamodb wait table-exists --table-name "${{ steps.acct.outputs.LOCK_TABLE }}"
            echo "Created lock table: ${{ steps.acct.outputs.LOCK_TABLE }}"

      - name: Clean local terraform artifacts
        working-directory: infra
        run: rm -rf .terraform .terraform.lock.hcl terraform.tfstate terraform.tfstate.backup

      - name: Terraform init
        working-directory: infra
        run: terraform init -backend-config=backend.hcl

      - name: Terraform apply (bootstrap, no instances)
        working-directory: infra
        run: |
          set -e
          terraform plan -var-file=env/dev.tfvars -var="desired_count=0" -var="image_tag=latest" -out=tfplan
          terraform apply -input=false -auto-approve tfplan

      - name: Terraform outputs
        id: tf_outputs
        working-directory: infra
        run: |
          set -e
          echo "repo_uri=$(terraform output -raw ecr_repository_url)" >> $GITHUB_OUTPUT
          echo "asg_name=$(terraform output -raw asg_name)" >> $GITHUB_OUTPUT
          echo "alb_dns=$(terraform output -raw alb_dns)" >> $GITHUB_OUTPUT

  build_and_push:
    name: Build & push Docker image to ECR
    needs: infra_bootstrap
    runs-on: ubuntu-latest
    timeout-minutes: 45
    outputs:
      image_tag: ${{ steps.vars.outputs.sha }}
      build_time: ${{ steps.vars.outputs.build_time }}
    steps:
      - uses: actions/checkout@v4

      - name: Compute image tag + build time
        id: vars
        run: |
          echo "sha=${GITHUB_SHA}" >> $GITHUB_OUTPUT
          echo "build_time=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" >> $GITHUB_OUTPUT

      - name: Set up Docker Buildx (multi-arch)
        uses: docker/setup-buildx-action@v3

      - name: Configure AWS credentials (GitHub Secrets)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build & push image (multi-arch)
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile
          platforms: linux/amd64,linux/arm64
          push: true
          build-args: |
            APP_VERSION=${{ steps.vars.outputs.sha }}
            APP_BUILD_TIME=${{ steps.vars.outputs.build_time }}
          tags: |
            ${{ needs.infra_bootstrap.outputs.repo_uri }}:${{ steps.vars.outputs.sha }}

  deploy:
    name: Deploy (Terraform apply + ASG instance refresh)
    needs: [infra_bootstrap, build_and_push]
    runs-on: ubuntu-latest
    timeout-minutes: 60
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials (GitHub Secrets)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.6

      - name: Write backend.hcl (remote state config)
        env:
          TF_STATE_BUCKET: ${{ env.PROJECT_NAME }}-tfstate-${{ github.repository_owner }}
          TF_LOCK_TABLE:  ${{ env.PROJECT_NAME }}-tflock-${{ github.repository_owner }}
        run: |
          cat > infra/backend.hcl <<EOF
          bucket         = "$TF_STATE_BUCKET"
          key            = "${{ env.PROJECT_NAME }}/terraform.tfstate"
          region         = "${{ env.AWS_REGION }}"
          dynamodb_table = "$TF_LOCK_TABLE"
          encrypt        = true
          EOF
          echo "Wrote infra/backend.hcl"

      - name: Terraform init
        working-directory: infra
        run: terraform init -backend-config=backend.hcl

      - name: Terraform apply (set image_tag + desired_count)
        working-directory: infra
        run: |
          set -e
          for i in 1 2; do
            terraform plan               -var-file=env/dev.tfvars               -var="image_tag=${{ needs.build_and_push.outputs.image_tag }}"               -out=tfplan

            if terraform apply -input=false -auto-approve tfplan; then
              exit 0
            fi

            echo "Apply attempt $i failed; retrying in 30s..."
            sleep 30
          done
          echo "Terraform apply failed after retries"
          exit 1

      - name: Start ASG instance refresh
        env:
          ASG_NAME: ${{ needs.infra_bootstrap.outputs.asg_name }}
        run: |
          set -euo pipefail
          REFRESH_ID=$(aws autoscaling start-instance-refresh             --auto-scaling-group-name "$ASG_NAME"             --preferences MinHealthyPercentage=50,InstanceWarmup=120             --region "${{ env.AWS_REGION }}"             --query 'InstanceRefreshId' --output text)
          echo "Started instance refresh: $REFRESH_ID"
          echo "REFRESH_ID=$REFRESH_ID" >> $GITHUB_ENV

      - name: Wait for instance refresh to complete
        env:
          ASG_NAME: ${{ needs.infra_bootstrap.outputs.asg_name }}
        run: |
          set -euo pipefail
          for _ in {1..30}; do
            STATUS=$(aws autoscaling describe-instance-refreshes               --auto-scaling-group-name "$ASG_NAME"               --instance-refresh-ids "$REFRESH_ID"               --region "${{ env.AWS_REGION }}"               --query 'InstanceRefreshes[0].Status' --output text)
            echo "Instance refresh status: $STATUS"
            if [ "$STATUS" = "Successful" ]; then exit 0; fi
            if [ "$STATUS" = "Failed" ] || [ "$STATUS" = "Cancelled" ]; then
              aws autoscaling describe-instance-refreshes                 --auto-scaling-group-name "$ASG_NAME"                 --instance-refresh-ids "$REFRESH_ID"                 --region "${{ env.AWS_REGION }}"
              exit 1
            fi
            sleep 20
          done
          echo "Instance refresh timed out"
          exit 1

      - name: Outputs (ALB DNS)
        run: |
          echo "ALB DNS: ${{ needs.infra_bootstrap.outputs.alb_dns }}"